1. Read through my entire bin/ and install.sh in ultrathink and generate a full, working understanding of this codebase.
2. Update the README mimicing the existing format of simplicity over verboseness. You may modify existing entries but must keep the install at the top. Please modify it to include the other applications. No emojiis please.
3. Generate a new file called NEWCLAUDE.md and generate a new CLAUDE.md file that you would use in the future to best prepare yourself to manage this repo. The goal of this repo is to create scripts that run as commands on MacOS (and potentially Linux) to augment user effeciency. The contents of that file will replace the existing contents here.

Once that is complete, we'll move on to the next phase. ccombo needs some updated features:
1. Ensure that when ccombo executes its primary function, it honors .combosource, .comboignore and .gitignore and the types of globs that can appear within them. In terms of supersedence:
   1. .comboignore is top priority and overrides all others
   2. .combosource is next in line for priority, overriding
   3. .gitignore and any globs (formats) within
2. If generation encounters a nested .combosource file, honor any entries that are NOT part of the root filepath for this generation. This means we should be able to source files from outside the filepath if they are required even if these were possibly nested in a subfolder. All .comboignore files encountered should respect their entries for that filepath only.
3. Generation should never include the following UNLESS they are specifically included in the .combosource file:
   1. .git folders and their contents
   2. .gitignore files
   3. .gitattributes files
4. ccombo with no arguments in a folder with no .combosource should prompt the user to ask if they want to generate for the current directory.
5. running ccombo and a directory (e.g. ccombo test) should generate the output 
6. When adding files and folders to .combosource and .comboignore, check if the file path is $HOME, $GITHUBPATH and use these variables instead of the absolute path. Make sure the rest of the application can handle that.

# Git workflow for feature development

## On each feature request:
- Make a new branch: `feature/xxx-desc` off `main`
- Use gitversion command with
- Commit often: meaningful messages like `feat:`, `fix:`, `refactor:`  
- Always `git push origin feature/xxx-desc`

## Keep branches up‑to‑date:
- Before final review, `git fetch origin && git rebase origin/main`
- Run tests and fix conflicts

## When ready:
- Open a Pull Request to `main`  
- Wait for approvals and CI passes  
- Merge only through PR (never `git merge` directly to main)

## After merge:
- Switch to `main`, `git pull`
- Create an annotated tag `vX.Y.Z – summary of changes`
- `git push origin vX.Y.Z`

## If a new feature updates past code:
- Rebase feature branch on latest `main`
- Fix, test, commit, and PR again

## Branch naming & commit style:
- Branch names: `feature/short‑desc‑or‑ticket` or `bugfix/xyz`
- Commit style:  
  `feat: ` new feature  
  `fix: ` bug fix  
  `docs: ` documentation  
  `chore: ` non‑code updates

Claude follows this and never pushes directly to `main`—it always creates a branch, pushes to remote, rebases, opens a PR, and tags after—ensuring full tracking.

