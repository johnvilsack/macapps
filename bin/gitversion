#!/bin/bash
# gitversion - Semantic versioning automation CLI tool
set -euo pipefail

VERSION_FILE=".version"
CHANGELOG_FILE="CHANGELOG.md"

# Function to read current version
read_version() {
    if [[ -f "$VERSION_FILE" ]]; then
        cat "$VERSION_FILE"
    else
        echo "0.0.0"
    fi
}

# Parse semantic version into components
parse_version() {
    local version=$1
    # Handle both 1.2.3 and 1.2.3-4 formats
    if [[ "$version" =~ ^v?([0-9]+)\.([0-9]+)\.([0-9]+)(-([0-9]+))?$ ]]; then
        local major="${BASH_REMATCH[1]}"
        local minor="${BASH_REMATCH[2]}"
        local patch="${BASH_REMATCH[3]}"
        local sub="${BASH_REMATCH[5]:-0}"
        echo "$major $minor $patch $sub"
    else
        echo "0 0 0 0"
    fi
}

# Increment version based on type
increment_version() {
    local current=$1
    local increment_type=$2
    
    read -r major minor patch sub <<< "$(parse_version "$current")"
    
    case "$increment_type" in
        major)
            echo "$((major + 1)).0.0"
            ;;
        minor)
            echo "$major.$((minor + 1)).0"
            ;;
        patch)
            echo "$major.$minor.$((patch + 1))"
            ;;
        sub)
            if [[ "$sub" == "0" ]]; then
                echo "$major.$minor.$patch-1"
            else
                echo "$major.$minor.$patch-$((sub + 1))"
            fi
            ;;
        *)
            echo "$current"
            ;;
    esac
}

# Process escape sequences in message
process_escape_sequences() {
    local message="$1"
    # Process common escape sequences
    printf '%b' "$message"
}

# Extract title line from message (first line before \n)
get_title_line() {
    local message="$1"
    echo "$message" | head -n1
}

# Determine increment type from commit message
get_increment_type() {
    local message="$1"
    local title_line=$(get_title_line "$message")
    local prefix
    
    # Check for colon format first (MAJOR: message)
    if [[ "$title_line" == *":"* ]]; then
        prefix=$(echo "$title_line" | cut -d: -f1 | tr '[:upper:]' '[:lower:]' | xargs)
    else
        # Check for space format (MAJOR message)
        prefix=$(echo "$title_line" | cut -d' ' -f1 | tr '[:upper:]' '[:lower:]' | xargs)
    fi
    
    case "$prefix" in
        major|release|breaking)
            echo "major"
            ;;
        minor|feature|feat)
            echo "minor"
            ;;
        patch|fix)
            echo "patch"
            ;;
        *)
            echo "sub"
            ;;
    esac
}

# Update changelog
update_changelog() {
    local version=$1
    local message=$2
    local date=$(date +%Y-%m-%d)
    
    # Get title line and remove version suffix if present
    local title_line=$(get_title_line "$message")
    local clean_message=$(echo "$title_line" | sed -E 's/ \[v?[0-9]+\.[0-9]+\.[0-9]+\]$//')
    
    # Create changelog if it doesn't exist
    if [[ ! -f "$CHANGELOG_FILE" ]]; then
        echo "# Changelog" > "$CHANGELOG_FILE"
        echo "" >> "$CHANGELOG_FILE"
    fi
    
    # Create temp file with new entry
    local temp_file=$(mktemp)
    
    # Add new version header
    echo "## [$version] - $date" > "$temp_file"
    echo "- $clean_message" >> "$temp_file"
    echo "" >> "$temp_file"
    
    # Append existing changelog content (skip the header)
    if [[ -f "$CHANGELOG_FILE" ]]; then
        tail -n +3 "$CHANGELOG_FILE" >> "$temp_file" 2>/dev/null || true
    fi
    
    # Prepend header and save
    echo "# Changelog" > "$CHANGELOG_FILE"
    echo "" >> "$CHANGELOG_FILE"
    cat "$temp_file" >> "$CHANGELOG_FILE"
    rm "$temp_file"
}

# Create git tag
create_tag() {
    local version=$1
    local increment_type=$2
    
    # Create tag for major and minor versions
    if [[ "$increment_type" == "major" ]] || [[ "$increment_type" == "minor" ]]; then
        local tag_name
        if [[ "$increment_type" == "major" ]]; then
            tag_name="release-v$version"
        else
            tag_name="v$version"
        fi
        
        git tag -a "$tag_name" -m "Release version $version"
        echo "Created tag: $tag_name"
    fi
}

# Find git repository root
find_git_root() {
    local current_dir=$(pwd)
    
    while [[ "$current_dir" != "/" ]]; do
        if [[ -d "$current_dir/.git" ]]; then
            echo "$current_dir"
            return 0
        fi
        current_dir=$(dirname "$current_dir")
    done
    
    return 1
}

# Open editor for commit message
open_editor() {
    local temp_file=$(mktemp)
    local editor="${EDITOR:-nano}"
    
    # Open editor
    "$editor" "$temp_file"
    
    # Read the content
    if [[ -s "$temp_file" ]]; then
        cat "$temp_file"
        rm "$temp_file"
        return 0
    else
        rm "$temp_file"
        echo "Error: Empty commit message"
        return 1
    fi
}

# Process versioning for a commit message
process_version() {
    local commit_message="$1"
    local repo_path=${2:-}
    
    # Process escape sequences in the message
    commit_message=$(process_escape_sequences "$commit_message")
    
    # If no repo_path provided, find git root from current location
    if [[ -z "$repo_path" ]]; then
        repo_path=$(find_git_root)
        if [[ $? -ne 0 ]]; then
            echo "Error: Not in a git repository or subdirectory"
            exit 1
        fi
    fi
    
    # Change to repo directory
    cd "$repo_path"
    
    # Check if we're in a git repo
    if [[ ! -d ".git" ]]; then
        echo "Error: Not in a git repository: $repo_path"
        exit 1
    fi
    
    # Create .version file if it doesn't exist
    if [[ ! -f "$VERSION_FILE" ]]; then
        echo "0.0.0" > "$VERSION_FILE"
        echo "Created $VERSION_FILE with initial version 0.0.0"
    fi
    
    local increment_type=$(get_increment_type "$commit_message")
    local current_version=$(read_version)
    local new_version="$current_version"
    
    if [[ "$increment_type" != "none" ]]; then
        new_version=$(increment_version "$current_version" "$increment_type")
        
        # Update version file
        echo "$new_version" > "$VERSION_FILE"
        echo "Updated version: $current_version â†’ $new_version"
        
        # Update changelog
        update_changelog "$new_version" "$commit_message"
        echo "Updated $CHANGELOG_FILE"
        
        # Inject version into title line only
        local title_line=$(get_title_line "$commit_message")
        local body_lines=$(echo "$commit_message" | tail -n +2)
        
        if [[ -n "$body_lines" ]]; then
            commit_message="${title_line} [${new_version}]\n${body_lines}"
        else
            commit_message="${title_line} [${new_version}]"
        fi
    fi
    
    # Create temp file for multiline commit
    local temp_commit_file=$(mktemp)
    printf '%b' "$commit_message" > "$temp_commit_file"
    
    # Add all files and commit
    git add .
    if git commit --allow-empty -F "$temp_commit_file"; then
        local display_msg=$(get_title_line "$commit_message")
        echo "Committed with message: $display_msg"
    else
        echo "Error: Failed to commit"
        rm "$temp_commit_file"
        exit 1
    fi
    
    rm "$temp_commit_file"
    
    # Create tag if needed
    if [[ "$increment_type" != "none" ]]; then
        create_tag "$new_version" "$increment_type"
    fi
    
    # Push changes
    git push origin HEAD
    if [[ "$increment_type" == "major" ]] || [[ "$increment_type" == "minor" ]]; then
        git push --tags
    fi
    echo "Pushed to remote"
}

# Find repository in GITHUBPATH
find_repo() {
    local repo_name=$1
    
    if [[ -z "${GITHUBPATH:-}" ]]; then
        echo "Error: GITHUBPATH environment variable not set"
        exit 1
    fi
    
    if [[ ! -d "$GITHUBPATH" ]]; then
        echo "Error: GITHUBPATH directory not found: $GITHUBPATH"
        exit 1
    fi
    
    local repo_path="$GITHUBPATH/$repo_name"
    if [[ -d "$repo_path" ]]; then
        echo "$repo_path"
    else
        echo "Error: Repository '$repo_name' not found in $GITHUBPATH"
        exit 1
    fi
}

# Main function
main() {
    local original_pwd=$(pwd)
    
    # Handle test mode first
    if [[ "$1" == "test" ]] && [[ -n "${2:-}" ]]; then
        echo "=== TEST MODE ==="
        local test_message=$(process_escape_sequences "$2")
        local increment_type=$(get_increment_type "$test_message")
        local current_version=$(read_version)
        echo "Input message: '$2'"
        echo "Processed message:"
        printf '%b\n' "$test_message"
        echo "Detected increment type: '$increment_type'"
        echo "Current version: '$current_version'"
        if [[ "$increment_type" != "none" ]]; then
            local new_version=$(increment_version "$current_version" "$increment_type")
            echo "New version would be: '$new_version'"
            echo "Final commit message would be:"
            local title_line=$(get_title_line "$test_message")
            local body_lines=$(echo "$test_message" | tail -n +2)
            if [[ -n "$body_lines" ]]; then
                printf '%b\n' "${title_line} [${new_version}]\\n${body_lines}"
            else
                printf '%b\n' "${title_line} [${new_version}]"
            fi
        else
            echo "No version change would occur"
        fi
        exit 0
    fi
    
    case $# in
        0)
            # gitversion (no args) - commit in current repo
            process_version "simple changes"
            ;;
        1)
            if [[ "$1" == "--help" ]] || [[ "$1" == "-h" ]]; then
                # Show usage
                echo "Usage:"
                echo "  gitversion                           - Commit current repo with 'simple changes'"
                echo "  gitversion \"message\"                 - Commit current repo with custom message"
                echo "  gitversion -m | --multiline          - Open editor for multiline message"
                echo "  gitversion reponame \"message\"        - Commit remote repo with custom message"
                echo ""
                echo "Escape sequences supported: \\n (newline), \\t (tab), \\r (carriage return)"
                echo ""
                echo "Version prefixes (case-insensitive):"
                echo "  major|release|breaking: <message>   - Bumps major version"
                echo "  minor|feature|feat: <message>       - Bumps minor version"
                echo "  patch|fix: <message>                - Bumps patch version"
                exit 0
            elif [[ "$1" == "-m" ]] || [[ "$1" == "--multiline" ]]; then
                # Open editor for multiline message
                local editor_message
                if editor_message=$(open_editor); then
                    process_version "$editor_message"
                else
                    exit 1
                fi
            else
                # Single argument is always a commit message for current repo
                process_version "$1"
            fi
            ;;
        2)
            if [[ "$1" == "-m" ]] || [[ "$1" == "--multiline" ]]; then
                # gitversion -m <reponame> - open editor for remote repo
                local repo_path=$(find_repo "$2")
                local editor_message
                if editor_message=$(open_editor); then
                    process_version "$editor_message" "$repo_path"
                    cd "$original_pwd"
                else
                    exit 1
                fi
            else
                # gitversion <reponame> "Commit message here" - commit in remote repo
                local repo_path=$(find_repo "$1")
                process_version "$2" "$repo_path"
                cd "$original_pwd"
            fi
            ;;
        *)
            echo "Usage:"
            echo "  gitversion                           - Commit current repo with 'simple changes'"
            echo "  gitversion \"message\"                 - Commit current repo with custom message"
            echo "  gitversion -m | --multiline          - Open editor for multiline message"
            echo "  gitversion reponame \"message\"        - Commit remote repo with custom message"
            echo "  gitversion -m reponame               - Open editor for remote repo"
            echo "  gitversion test \"message\"            - Test mode: show what would happen"
            echo ""
            echo "Escape sequences supported: \\n (newline), \\t (tab), \\r (carriage return)"
            echo ""
            echo "Version prefixes (case-insensitive):"
            echo "  major|release|breaking[: ]<message> - Bumps major version"
            echo "  minor|feature|feat[: ]<message>     - Bumps minor version"
            echo "  patch|fix[: ]<message>              - Bumps patch version"
            echo "  (no prefix)                         - Bumps subversion (-1, -2, etc.)"
            exit 1
            ;;
    esac
}

main "$@"
