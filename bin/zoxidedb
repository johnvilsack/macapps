#!/usr/bin/env bash
set -euo pipefail

usage(){
  cat <<EOF
Usage:
  $0 tocsv   [-k|--keep-uri] input.txt   output.csv
  $0 totext       input.csv             output.txt
  $0 sort         input.txt             output.txt
  $0 getzoxide    output.txt [keywords...]
EOF
  exit 1
}

# ─── Helpers ────────────────────────────────────────────────────────────────────

# Escape and quote one CSV field
quote_csv(){
  local s="${1//\"/\"\"}"
  printf '"%s"' "$s"
}

# Strip surrounding quotes and un-escape inner quotes
strip_quotes(){
  local s="$1"
  s="${s#\"}"; s="${s%\"}"
  printf '%s' "${s//\"\"/\"}"
}

# ─── Mode: tocsv ────────────────────────────────────────────────────────────────

paths_to_csv(){
  local keep_uri="$1"; local input="$2"; local output="$3"
  : > "$output"
  while IFS=$'\t' read -r raw_score raw_path; do
    [[ -z "$raw_score" ]] && continue

    # Trim whitespace
    score="${raw_score#"${raw_score%%[![:space:]]*}"}"
    score="${score%"${score##*[![:space:]]}"}"
    path="${raw_path#"${raw_path%%[![:space:]]*}"}"
    path="${path%"${path##*[![:space:]]}"}"
    # Remove leading slash for splitting
    path="${path#/}"

    # Split into segments
    IFS='/' read -r -a parts <<< "$path"

    # Build CSV row
    row="$(quote_csv "$score")"
    [[ "$keep_uri" == yes ]] && row+=",$(quote_csv "/$path")"
    for seg in "${parts[@]}"; do
      row+=",$(quote_csv "$seg")"
    done

    printf '%s\n' "$row" >> "$output"
  done < "$input"
}

# ─── Mode: totext ───────────────────────────────────────────────────────────────

csv_to_paths(){
  local input="$1"; local output="$2"
  : > "$output"
  while IFS= read -r line || [[ -n "$line" ]]; do
    [[ -z "$line" ]] && continue

    # Split on commas (does not support commas inside fields in tests)
    IFS=',' read -r -a fields <<< "$line"
    for i in "${!fields[@]}"; do
      fields[$i]="$(strip_quotes "${fields[$i]}")"
    done

    local score="${fields[0]}"
    local start=1; local uri=""

    # If second field starts with / and there are >2 fields, treat as URI
    if [[ "${#fields[@]}" -gt 2 && "${fields[1]}" == /* ]]; then
      uri="${fields[1]}"
      start=2
    fi

    local path=""
    for ((i=start; i<${#fields[@]}; i++)); do
      [[ -z "${fields[i]}" ]] && continue
      path+="/${fields[i]}"
    done
    [[ -z "$path" ]] && path="/"

    # Force one decimal
    printf '%.1f\t%s\n' "$score" "${uri:-$path}" >> "$output"
  done < "$input"
}

# ─── Mode: sort ─────────────────────────────────────────────────────────────────

sort_hier(){
  local input="$1"; local output="$2"
  # depth<TAB>path<TAB>score
  awk -F$'\t' '{
    d = split($2, a, "/") - 1
    printf "%d\t%s\t%s\n", d, $2, $1
  }' "$input" \
  | sort -t $'\t' -k1,1n -k2,2 \
  | awk -F$'\t' '{ print $3 "\t" $2 }' \
  > "$output"
}

# ─── Mode: getzoxide ────────────────────────────────────────────────────────────

getzoxide(){
  local output="$1"; shift
  local tmp
  tmp="$(mktemp)"
  trap 'rm -f "$tmp"' RETURN
  zoxide query --list --all --score "$@" > "$tmp"

  : > "$output"
  while IFS=$'\t' read -r score path; do
    [[ -z "$score" ]] && continue
    # Fallback if no tab
    if [[ -z "$path" ]]; then
      read -r score path <<< "$score"
    fi
    printf '%s\t%s\n' "$score" "$path" >> "$output"
  done < "$tmp"
}

# ─── Dispatch ──────────────────────────────────────────────────────────────────

case "${1:-}" in
  tocsv)
    if [[ "$2" == "--keep-uri" || "$2" == "-k" ]]; then
      paths_to_csv yes "$3" "$4"
    else
      paths_to_csv no  "$2" "$3"
    fi
    ;;
  totext)
    csv_to_paths "$2" "$3"
    ;;
  sort)
    sort_hier "$2" "$3"
    ;;
  getzoxide)
    getzoxide "$2" "${@:3}"
    ;;
  *)
    usage
    ;;
esac
