#!/usr/bin/env bash
set -euo pipefail

usage(){
  cat <<EOF
Usage:
  $0 tocsv   [-k|--keep-uri] input.txt   output.csv
  $0 totext       input.csv             output.txt
  $0 sort         input.txt             output.txt
  $0 toz          input.txt             output.z
  $0 getzoxide    output.txt [keywords...]
EOF
  exit 1
}

# ─── Helpers ────────────────────────────────────────────────────────────────────

# Escape and quote one CSV field
quote_csv(){
  local s="${1//\"/\"\"}"
  printf '"%s"' "$s"
}

# Strip surrounding quotes and un-escape inner quotes
strip_quotes(){
  local s="$1"
  s="${s#\"}"; s="${s%\"}"
  printf '%s' "${s//\"\"/\"}"
}

# ─── Mode: tocsv ────────────────────────────────────────────────────────────────

paths_to_csv(){
  local keep_uri="$1"; shift
  local input="$1" output="$2"
  : > "$output"
  while IFS=$'\t' read -r raw_score raw_path; do
    [[ -z "$raw_score" ]] && continue

    # Trim score and path
    score="${raw_score#"${raw_score%%[![:space:]]*}"}"
    score="${score%"${score##*[![:space:]]}"}"
    path="${raw_path#"${raw_path%%[![:space:]]*}"}"
    path="${path%"${path##*[![:space:]]}"}"
    path="${path#/}"

    # Split into segments
    IFS='/' read -r -a parts <<< "$path"

    quote_csv "$score" >>"$output"
    if [[ "$keep_uri" == yes ]]; then
      printf ',' >>"$output"
      quote_csv "/$path" >>"$output"
    fi
    for seg in "${parts[@]}"; do
      printf ',' >>"$output"
      quote_csv "$seg" >>"$output"
    done
    printf '\n' >>"$output"
  done <"$input"
}

# ─── Mode: totext ───────────────────────────────────────────────────────────────

csv_to_paths(){
  awk -F',' '
    function strip(s){ gsub(/^"|"$/, "", s); gsub(/""/,"\"",s); return s }
    {
      s = strip($1)+0
      # detect URI
      if (strip($2) ~ /^\// && NF>2) {
        uri = strip($2); start=3
      } else {
        uri=""; start=2
      }
      path=""
      for(i=start;i<=NF;i++){
        f=strip($i)
        if(f!="") path=path"/"f
      }
      if(path=="") path="/"
      printf("%.1f\t%s\n", s, uri?uri:path)
    }
  ' "$1" > "$2"
}


# ─── Mode: sort ─────────────────────────────────────────────────────────────────

sort_hier(){
  local input="$1"; local output="$2"
  # depth<TAB>path<TAB>score
  awk -F$'\t' '{
    d = split($2, a, "/") - 1
    printf "%d\t%s\t%s\n", d, $2, $1
  }' "$input" \
  | sort -t $'\t' -k1,1n -k2,2 \
  | awk -F$'\t' '{ print $3 "\t" $2 }' \
  > "$output"
}

# ─── Mode: toz ──────────────────────────────────────────────────────────────────

toz(){
  local input="$1" output="$2"
  : > "$output"
  while IFS=$'\t' read -r score path; do
    [[ -z "$score" ]] && continue
    # Fallback if no tab
    if [[ -z "$path" ]]; then
      read -r score path <<< "$score"
    fi
    # Convert score to z format (multiply by 4) and add timestamp placeholder
    local z_score=$((${score%.*} * 4))
    printf '%s|%s|1\n' "$path" "$z_score" >> "$output"
  done < "$input"
}

# ─── Mode: getzoxide ────────────────────────────────────────────────────────────

getzoxide(){
  local output="$1"; shift
  local tmp
  tmp="$(mktemp)"
  trap 'rm -f "$tmp"' RETURN
  zoxide query --list --all --score "$@" > "$tmp"

  : > "$output"
  while IFS=$'\t' read -r score path; do
    [[ -z "$score" ]] && continue
    # Fallback if no tab
    if [[ -z "$path" ]]; then
      read -r score path <<< "$score"
    fi
    printf '%s\t%s\n' "$score" "$path" >> "$output"
  done < "$tmp"
}

# ─── Dispatch ──────────────────────────────────────────────────────────────────

case "${1:-}" in
  tocsv)
    if [[ "$2" == "--keep-uri" || "$2" == "-k" ]]; then
      paths_to_csv yes "$3" "$4"
    else
      paths_to_csv no  "$2" "$3"
    fi
    ;;
  totext)
    csv_to_paths "$2" "$3"
    ;;
  sort)
    sort_hier "$2" "$3"
    ;;
  toz)
    toz "$2" "$3"
    ;;
  getzoxide)
    getzoxide "$2" "${@:3}"
    ;;
  *)
    usage
    ;;
esac
