#!/usr/bin/env bash
# Ensure we are running under bash even if invoked from zsh/dash
[ -n "${BASH_VERSION:-}" ] || exec /usr/bin/env bash "$0" "$@"
set -euo pipefail

# clog - Cross-platform colorized logging utility with file output
# Usage: clog LEVEL "message"
# Example: clog INFO "This is an informational message"

VERSION="2.0.0"
PROGRAM_NAME="clog"

# ============================================================================
# DEFAULT CONFIGURATION SECTION
# ============================================================================

DEFAULT_LOG_PATH="$HOME/Library/Logs/clog"
DEFAULT_LOG_FILENAME="main.log"
DEFAULT_LOG_TAG="${CLOG_TAG:-clog}"
DEFAULT_SHOW_TIMESTAMP=false
DEFAULT_SHOW_PID=false
DEFAULT_OUTPUT_JSON=false
DEFAULT_DISABLE_COLOR=false
DEFAULT_DISPLAY_TAG=false

DEFAULT_MAX_SIZE=5242880
DEFAULT_MAX_ROTATED_FILES=10

# ============================================================================
# COLOR DEFINITIONS
# ============================================================================
declare -A COLORS=(
    ["INFO"]="\e[1;38;5;33m"
    ["WARNING"]="\e[1;38;5;208m"
    ["ERROR"]="\e[1;38;5;197m"
    ["SUCCESS"]="\e[1;38;5;46m"
    ["DEBUG"]="\e[1;38;5;93m"
    ["TRACE"]="\e[1;38;5;207m"
)
COLOR_RESET="\e[0m"

# ============================================================================
# INITIALIZE VARIABLES
# ============================================================================
LOG_PATH="${CLOG_PATH:-$DEFAULT_LOG_PATH}"
LOG_FILENAME="${CLOG_FILENAME:-$DEFAULT_LOG_FILENAME}"
LOG_TAG="${CLOG_TAG:-$DEFAULT_LOG_TAG}"
SHOW_TIMESTAMP="${CLOG_SHOW_TIMESTAMP:-$DEFAULT_SHOW_TIMESTAMP}"
SHOW_PID="${CLOG_SHOW_PID:-$DEFAULT_SHOW_PID}"
OUTPUT_JSON="${CLOG_OUTPUT_JSON:-$DEFAULT_OUTPUT_JSON}"
DISABLE_COLOR="${CLOG_DISABLE_COLOR:-$DEFAULT_DISABLE_COLOR}"
MAX_SIZE="${CLOG_MAX_SIZE:-$DEFAULT_MAX_SIZE}"
MAX_ROTATED_FILES="${CLOG_MAX_ROTATED_FILES:-$DEFAULT_MAX_ROTATED_FILES}"
DISPLAY_TAG="${CLOG_DISPLAY_TAG:-$DEFAULT_DISPLAY_TAG}"

if [[ ! -t 1 ]] || [[ -n "${NO_COLOR:-}" ]] || [[ "${TERM:-}" == "dumb" ]]; then
    DISABLE_COLOR=true
fi

# ============================================================================
# FUNCTIONS
# ============================================================================
show_help() {
    cat << EOF
$PROGRAM_NAME v$VERSION - Cross-platform colorized logging utility with file output

USAGE:
    $PROGRAM_NAME [OPTIONS] LEVEL "message"

LEVELS:
    INFO, WARNING, ERROR, SUCCESS, DEBUG, TRACE
EOF
}

ensure_log_directory() {
    local dir="$1"
    if [[ ! -d "$dir" ]]; then
        mkdir -p "$dir" || {
            echo "Error: Failed to create log directory: $dir" >&2
            exit 1
        }
    fi
}

rotate_log_if_needed() {
    local logfile="$1"
    local maxsize="$2"
    local maxfiles="$3"
    if [[ -f "$logfile" ]]; then
        local filesize
        if [[ "$OSTYPE" == "darwin"* ]]; then
            filesize=$(stat -f%z "$logfile" 2>/dev/null || echo 0)
        else
            filesize=$(stat -c%s "$logfile" 2>/dev/null || echo 0)
        fi
        if [[ $filesize -gt $maxsize ]]; then
            local timestamp
            timestamp=$(date +%Y%m%d%H%M%S)
            local rotated_name="${logfile}.${timestamp}"
            mv "$logfile" "$rotated_name"
            gzip "$rotated_name"
            touch "$logfile"
            chmod 644 "$logfile"
            if [[ $maxfiles -gt 0 ]]; then
                local count=0
                for old_log in $(ls -t "${logfile}".*.gz 2>/dev/null | tail -r); do
                    ((count++))
                    if [[ $count -gt $maxfiles ]]; then
                        rm -f "$old_log"
                    fi
                done
            fi
        fi
    else
        touch "$logfile"
        chmod 644 "$logfile"
    fi
}

format_file_timestamp() {
    date '+%a %b %d %H:%M:%S %Y'
}

output_json() {
    local level="$1"
    local message="$2"
    local timestamp
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%S.%3NZ" 2>/dev/null || date -u +"%Y-%m-%dT%H:%M:%SZ")
    printf '{"timestamp":"%s","level":"%s","message":"%s","pid":%d,"tag":"%s"}\n' \
        "$timestamp" "$level" "$message" $$ "$LOG_TAG"
}

clog() {
    local level="$1"
    local message="$2"

    # safe missing key check
    if [[ -z "${COLORS[$level]+x}" ]]; then
        printf "${COLORS[ERROR]}[ERROR] Invalid log level: %s${COLOR_RESET}\n" "$level" >&2
        printf "Valid levels: %s\n" "$(printf "%s " "${!COLORS[@]}")" >&2
        return 1
    fi

    local logfile="${LOG_PATH}/${LOG_FILENAME}"
    ensure_log_directory "$LOG_PATH"
    rotate_log_if_needed "$logfile" "$MAX_SIZE" "$MAX_ROTATED_FILES"

    local file_timestamp
    file_timestamp=$(format_file_timestamp)
    local file_entry="[$file_timestamp] [$LOG_TAG] [$level]"
    if [[ "$SHOW_PID" == true ]]; then
        file_entry="$file_entry [$$]"
    fi
    file_entry="$file_entry $message"
    echo "$file_entry" >> "$logfile" || {
        echo "Error: Failed to write to log file: $logfile" >&2
    }

    if [[ "$OUTPUT_JSON" == true ]]; then
        output_json "$level" "$message"
    else
        local timestamp=""
        [[ "$SHOW_TIMESTAMP" == true ]] && timestamp="[$(date '+%H:%M:%S')] "
        local tag_and_pid=""
        if [[ "${DISPLAY_TAG,,}" == "true" ]]; then
            if [[ "$SHOW_PID" == true ]]; then
                tag_and_pid="$LOG_TAG[$$] "
            else
                tag_and_pid="$LOG_TAG "
            fi
        elif [[ "$SHOW_PID" == true ]]; then
            tag_and_pid="[$$] "
        fi
        printf "%s${COLORS[$level]}%s[%s]${COLOR_RESET} %s\n" \
            "$timestamp" "$tag_and_pid" "$level" "$message"
    fi
}

hrline() {
    echo "$(printf '\e[1;38;5;240m%*s\e[0m' "$(tput cols)" '' | tr ' ' '-')"
}

# ============================================================================
# MAIN
# ============================================================================
if [[ "${BASH_SOURCE[0]-$0}" == "$0" ]]; then
    if [[ $# -eq 1 && "${1^^}" == "LINE" ]]; then
        hrline
        exit 0
    fi
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help) show_help; exit 0 ;;
            -v|--version) echo "$PROGRAM_NAME v$VERSION"; exit 0 ;;
            -t|--timestamp) SHOW_TIMESTAMP=true; shift ;;
            -p|--pid) SHOW_PID=true; shift ;;
            -j|--json) OUTPUT_JSON=true; shift ;;
            -c|--no-color) DISABLE_COLOR=true; shift ;;
            --tag) LOG_TAG="$2"; shift 2 ;;
            --tag=*) LOG_TAG="${1#*=}"; shift ;;
            --path) LOG_PATH="$2"; shift 2 ;;
            --path=*) LOG_PATH="${1#*=}"; shift ;;
            --filename) LOG_FILENAME="$2"; shift 2 ;;
            --filename=*) LOG_FILENAME="${1#*=}"; shift ;;
            --max-size) MAX_SIZE="$2"; shift 2 ;;
            --max-size=*) MAX_SIZE="${1#*=}"; shift ;;
            --max-files) MAX_ROTATED_FILES="$2"; shift 2 ;;
            --max-files=*) MAX_ROTATED_FILES="${1#*=}"; shift ;;
            --display-tag) DISPLAY_TAG=true; shift ;;
            --no-display-tag) DISPLAY_TAG=false; shift ;;
            --display-tag=*) DISPLAY_TAG="${1#*=}"; shift ;;
            --no-display-tag=*) DISPLAY_TAG="${1#*=}"; shift ;;
            -*) echo "Error: Unknown option $1" >&2; show_help >&2; exit 1 ;;
            *) break ;;
        esac
    done
    if [[ $# -lt 2 ]]; then
        echo "Error: Missing required arguments" >&2
        echo "Usage: $PROGRAM_NAME LEVEL \"message\"" >&2
        exit 1
    fi
    LEVEL=$(echo "$1" | tr '[:lower:]' '[:upper:]')
    shift
    MESSAGE="$*"
    clog "$LEVEL" "$MESSAGE"
fi
