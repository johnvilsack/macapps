#!/usr/bin/env bash

# clog - Cross-platform colorized logging utility
# Usage: clog LEVEL "message"
# Example: clog INFO "This is an informational message"

set -euo pipefail

VERSION="1.0.0"
PROGRAM_NAME="clog"

# Color definitions (compatible with both macOS and Linux)
declare -A COLORS=(
    ["INFO"]="\033[1;34m"      # Blue
    ["WARNING"]="\033[1;33m"   # Yellow  
    ["ERROR"]="\033[1;31m"     # Red
    ["SUCCESS"]="\033[1;32m"   # Green
    ["DEBUG"]="\033[1;35m"     # Magenta
    ["TRACE"]="\033[1;36m"     # Cyan
)
COLOR_RESET="\033[0m"

# Default settings
LOG_TO_SYSLOG=true
LOG_TAG="${CLOG_TAG:-clog}"
SHOW_TIMESTAMP=false
SHOW_PID=false
OUTPUT_JSON=false
DISABLE_COLOR=false

# Check if we should disable color (non-TTY, NO_COLOR env var, etc.)
if [[ ! -t 1 ]] || [[ -n "${NO_COLOR:-}" ]] || [[ "${TERM:-}" == "dumb" ]]; then
    DISABLE_COLOR=true
fi

# Help function
show_help() {
    cat << EOF
$PROGRAM_NAME v$VERSION - Cross-platform colorized logging utility

USAGE:
    $PROGRAM_NAME [OPTIONS] LEVEL "message"

LEVELS:
    INFO        Informational messages (blue)
    WARNING     Warning messages (yellow)
    ERROR       Error messages (red)
    SUCCESS     Success messages (green)
    DEBUG       Debug messages (magenta)
    TRACE       Trace messages (cyan)

OPTIONS:
    -h, --help          Show this help message
    -v, --version       Show version information
    -t, --timestamp     Include timestamp in output
    -p, --pid           Include process ID in output
    -j, --json          Output in JSON format
    -n, --no-syslog     Don't log to syslog
    -c, --no-color      Disable colored output
    --tag TAG           Set syslog tag (default: clog)

ENVIRONMENT VARIABLES:
    CLOG_TAG           Default syslog tag
    NO_COLOR           Disable colors if set
    CLOG_NO_SYSLOG     Disable syslog if set

EXAMPLES:
    $PROGRAM_NAME INFO "Application started successfully"
    $PROGRAM_NAME WARNING "Disk space is low"
    $PROGRAM_NAME ERROR "Failed to connect to database"
    $PROGRAM_NAME SUCCESS "Backup completed"
    $PROGRAM_NAME --timestamp DEBUG "Debug information"
    $PROGRAM_NAME --json INFO "Status update"

COMPATIBILITY:
    - macOS (zsh/bash)
    - Linux (bash/zsh)
    - Works with systemd journal and traditional syslog
EOF
}

# JSON output function
output_json() {
    local level="$1"
    local message="$2"
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%S.%3NZ" 2>/dev/null || date -u +"%Y-%m-%dT%H:%M:%SZ")
    
    printf '{"timestamp":"%s","level":"%s","message":"%s","pid":%d,"tag":"%s"}\n' \
        "$timestamp" "$level" "$message" $$ "$LOG_TAG"
}

# Main logging function
clog() {
    local level="$1"
    local message="$2"
    
    # Validate log level
    if [[ -z "${COLORS[$level]:-}" ]]; then
        printf "${COLORS[ERROR]}[ERROR] Invalid log level: %s${COLOR_RESET}\n" "$level" >&2
        printf "Valid levels: %s\n" "$(printf "%s " "${!COLORS[@]}")" >&2
        return 1
    fi
    
    # Prepare message components
    local output_message="$message"
    local prefix="[$level]"
    
    if [[ "$SHOW_TIMESTAMP" == true ]]; then
        local timestamp
        # Use different date formats for macOS vs Linux compatibility
        if date --version >/dev/null 2>&1; then
            # GNU date (Linux)
            timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        else
            # BSD date (macOS)
            timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        fi
        prefix="$timestamp $prefix"
    fi
    
    if [[ "$SHOW_PID" == true ]]; then
        prefix="$prefix[$$]"
    fi
    
    # Output based on format
    if [[ "$OUTPUT_JSON" == true ]]; then
        output_json "$level" "$message"
    else
        if [[ "$DISABLE_COLOR" == true ]]; then
            printf "%s %s\n" "$prefix" "$output_message"
        else
            # Split prefix to only colorize the tag part
            if [[ "$SHOW_TIMESTAMP" == true ]]; then
                local timestamp_part="${prefix% \[*}"
                local tag_part="${prefix#* }"
                printf "%s ${COLORS[$level]}%s${COLOR_RESET} %s\n" "$timestamp_part" "$tag_part" "$output_message"
            else
                printf "${COLORS[$level]}%s${COLOR_RESET} %s\n" "$prefix" "$output_message"
            fi
        fi
    fi
    
    # Log to syslog if enabled
    if [[ "$LOG_TO_SYSLOG" == true ]] && [[ -z "${CLOG_NO_SYSLOG:-}" ]]; then
        # Use logger command - available on both macOS and Linux
        if command -v logger >/dev/null 2>&1; then
            # Determine syslog priority based on level
            local priority="user.info"
            case "$level" in
                ERROR)   priority="user.err" ;;
                WARNING) priority="user.warning" ;;
                INFO)    priority="user.info" ;;
                SUCCESS) priority="user.notice" ;;
                DEBUG)   priority="user.debug" ;;
                TRACE)   priority="user.debug" ;;
            esac
            
            logger -t "$LOG_TAG" -p "$priority" "[$level] $message" 2>/dev/null || true
        fi
    fi
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -v|--version)
            echo "$PROGRAM_NAME v$VERSION"
            exit 0
            ;;
        -t|--timestamp)
            SHOW_TIMESTAMP=true
            shift
            ;;
        -p|--pid)
            SHOW_PID=true
            shift
            ;;
        -j|--json)
            OUTPUT_JSON=true
            shift
            ;;
        -n|--no-syslog)
            LOG_TO_SYSLOG=false
            shift
            ;;
        -c|--no-color)
            DISABLE_COLOR=true
            shift
            ;;
        --tag)
            if [[ -n "${2:-}" ]]; then
                LOG_TAG="$2"
                shift 2
            else
                echo "Error: --tag requires a value" >&2
                exit 1
            fi
            ;;
        --tag=*)
            LOG_TAG="${1#*=}"
            shift
            ;;
        -*)
            echo "Error: Unknown option $1" >&2
            show_help >&2
            exit 1
            ;;
        *)
            break
            ;;
    esac
done

# Check for required arguments
if [[ $# -lt 2 ]]; then
    echo "Error: Missing required arguments" >&2
    echo "Usage: $PROGRAM_NAME LEVEL \"message\"" >&2
    exit 1
fi

# Extract level and message
LEVEL=$(echo "$1" | tr '[:lower:]' '[:upper:]')
shift
MESSAGE="$*"

# Call main logging function
clog "$LEVEL" "$MESSAGE"