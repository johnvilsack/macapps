#!/usr/bin/env bash
# Ensure we are running under bash even if invoked from zsh/dash
[ -n "${BASH_VERSION:-}" ] || exec /usr/bin/env bash "$0" "$@"
set -euo pipefail

# clog - Cross-platform colorized logging utility with file output
# Usage: clog LEVEL "message"
# Example: clog INFO "This is an informational message"

VERSION="2.0.1"
PROGRAM_NAME="clog"

# ============================================================================
# DEFAULT CONFIGURATION SECTION
# ============================================================================
DEFAULT_LOG_PATH="$HOME/Library/Logs/clog"
DEFAULT_LOG_FILENAME="main.log"
DEFAULT_LOG_TAG="${CLOG_TAG:-clog}"
DEFAULT_SHOW_TIMESTAMP=false
DEFAULT_SHOW_PID=false
DEFAULT_OUTPUT_JSON=false
DEFAULT_DISABLE_COLOR=false
DEFAULT_DISPLAY_TAG=false
DEFAULT_MAX_SIZE=5242880
DEFAULT_MAX_ROTATED_FILES=10

# ============================================================================
# COLOR DEFINITIONS - Using portable approach for bash 3.2+
# ============================================================================
get_color() {
    local level="$1"
    case "$level" in
        INFO)    echo "\e[1;38;5;33m" ;;
        WARNING) echo "\e[1;38;5;208m" ;;
        ERROR)   echo "\e[1;38;5;197m" ;;
        SUCCESS) echo "\e[1;38;5;46m" ;;
        DEBUG)   echo "\e[1;38;5;93m" ;;
        TRACE)   echo "\e[1;38;5;207m" ;;
        *)       echo "" ;;
    esac
}

is_valid_level() {
    local level="$1"
    case "$level" in
        INFO|WARNING|ERROR|SUCCESS|DEBUG|TRACE) return 0 ;;
        *) return 1 ;;
    esac
}

COLOR_RESET="\e[0m"

# ============================================================================
# INITIALIZE VARIABLES
# ============================================================================
LOG_PATH="${CLOG_PATH:-$DEFAULT_LOG_PATH}"
LOG_FILENAME="${CLOG_FILENAME:-$DEFAULT_LOG_FILENAME}"
LOG_TAG="${CLOG_TAG:-$DEFAULT_LOG_TAG}"
SHOW_TIMESTAMP="${CLOG_SHOW_TIMESTAMP:-$DEFAULT_SHOW_TIMESTAMP}"
SHOW_PID="${CLOG_SHOW_PID:-$DEFAULT_SHOW_PID}"
OUTPUT_JSON="${CLOG_OUTPUT_JSON:-$DEFAULT_OUTPUT_JSON}"
DISABLE_COLOR="${CLOG_DISABLE_COLOR:-$DEFAULT_DISABLE_COLOR}"
MAX_SIZE="${CLOG_MAX_SIZE:-$DEFAULT_MAX_SIZE}"
MAX_ROTATED_FILES="${CLOG_MAX_ROTATED_FILES:-$DEFAULT_MAX_ROTATED_FILES}"
DISPLAY_TAG="${CLOG_DISPLAY_TAG:-$DEFAULT_DISPLAY_TAG}"

if [[ ! -t 1 ]] || [[ -n "${NO_COLOR:-}" ]] || [[ "${TERM:-}" == "dumb" ]]; then
    DISABLE_COLOR=true
fi

# ============================================================================
# FUNCTIONS
# ============================================================================
show_help() {
    cat << EOF
$PROGRAM_NAME v$VERSION - Cross-platform colorized logging utility with file output

USAGE:
    $PROGRAM_NAME [OPTIONS] LEVEL "message"

LEVELS:
    INFO, WARNING, ERROR, SUCCESS, DEBUG, TRACE
EOF
}

ensure_log_directory() {
    local dir="$1"
    if [[ ! -d "$dir" ]]; then
        mkdir -p "$dir" || {
            echo "Error: Failed to create log directory: $dir" >&2
            exit 1
        }
    fi
}

rotate_log_if_needed() {
    local logfile="$1"
    local maxsize="$2"
    local maxfiles="$3"
    
    if [[ -f "$logfile" ]]; then
        local filesize
        if [[ "$OSTYPE" == "darwin"* ]]; then
            filesize=$(stat -f%z "$logfile" 2>/dev/null || echo 0)
        else
            filesize=$(stat -c%s "$logfile" 2>/dev/null || echo 0)
        fi
        
        if [[ $filesize -gt $maxsize ]]; then
            local timestamp
            timestamp=$(date +%Y%m%d%H%M%S)
            local rotated_name="${logfile}.${timestamp}"
            
            mv "$logfile" "$rotated_name"
            gzip "$rotated_name"
            touch "$logfile"
            chmod 644 "$logfile"
            
            if [[ $maxfiles -gt 0 ]]; then
                local count=0
                # Use ls -t for sorting, then reverse with tail -r on macOS or tac on Linux
                local old_logs
                if [[ "$OSTYPE" == "darwin"* ]]; then
                    old_logs=$(ls -t "${logfile}".*.gz 2>/dev/null | tail -r)
                else
                    old_logs=$(ls -t "${logfile}".*.gz 2>/dev/null | tac)
                fi
                
                for old_log in $old_logs; do
                    ((count++))
                    if [[ $count -gt $maxfiles ]]; then
                        rm -f "$old_log"
                    fi
                done
            fi
        fi
    else
        touch "$logfile"
        chmod 644 "$logfile"
    fi
}

format_file_timestamp() {
    date '+%a %b %d %H:%M:%S %Y'
}

output_json() {
    local level="$1"
    local message="$2"
    local timestamp
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%S.%3NZ" 2>/dev/null || date -u +"%Y-%m-%dT%H:%M:%SZ")
    
    printf '{"timestamp":"%s","level":"%s","message":"%s","pid":%d,"tag":"%s"}\n' \
        "$timestamp" "$level" "$message" $$ "$LOG_TAG"
}

clog() {
    local level="$1"
    local message="$2"
    
    # Validate log level
    if ! is_valid_level "$level"; then
        local error_color
        error_color=$(get_color "ERROR")
        printf "${error_color}[ERROR] Invalid log level: %s${COLOR_RESET}\n" "$level" >&2
        printf "Valid levels: INFO WARNING ERROR SUCCESS DEBUG TRACE\n" >&2
        return 1
    fi
    
    local logfile="${LOG_PATH}/${LOG_FILENAME}"
    ensure_log_directory "$LOG_PATH"
    rotate_log_if_needed "$logfile" "$MAX_SIZE" "$MAX_ROTATED_FILES"
    
    local file_timestamp
    file_timestamp=$(format_file_timestamp)
    
    local file_entry="[$file_timestamp] [$LOG_TAG] [$level]"
    if [[ "$SHOW_PID" == true ]]; then
        file_entry="$file_entry [$$]"
    fi
    file_entry="$file_entry $message"
    
    echo "$file_entry" >> "$logfile" || {
        echo "Error: Failed to write to log file: $logfile" >&2
    }
    
    if [[ "$OUTPUT_JSON" == true ]]; then
        output_json "$level" "$message"
    else
        local timestamp=""
        [[ "$SHOW_TIMESTAMP" == true ]] && timestamp="[$(date '+%H:%M:%S')] "
        
        local tag_and_pid=""
        # Handle case-insensitive comparison for DISPLAY_TAG
        local display_tag_lower
        display_tag_lower=$(echo "$DISPLAY_TAG" | tr '[:upper:]' '[:lower:]')
        
        if [[ "$display_tag_lower" == "true" ]]; then
            if [[ "$SHOW_PID" == true ]]; then
                tag_and_pid="$LOG_TAG[$$] "
            else
                tag_and_pid="$LOG_TAG "
            fi
        elif [[ "$SHOW_PID" == true ]]; then
            tag_and_pid="[$$] "
        fi
        
        local level_color
        level_color=$(get_color "$level")
        
        if [[ "$DISABLE_COLOR" == true ]]; then
            printf "%s%s[%s] %s\n" "$timestamp" "$tag_and_pid" "$level" "$message"
        else
            printf "%s${level_color}%s[%s]${COLOR_RESET} %s\n" \
                "$timestamp" "$tag_and_pid" "$level" "$message"
        fi
    fi
}

hrline() {
    local cols
    cols=$(tput cols 2>/dev/null || echo 80)
    if [[ "$DISABLE_COLOR" == true ]]; then
        printf '%*s\n' "$cols" '' | tr ' ' '-'
    else
        printf '\e[1;38;5;240m%*s\e[0m\n' "$cols" '' | tr ' ' '-'
    fi
}

# ============================================================================
# MAIN
# ============================================================================
if [[ "${BASH_SOURCE[0]:-$0}" == "${0}" ]]; then
    if [[ $# -eq 1 ]]; then
        # Convert to uppercase for comparison
        ARG_UPPER=$(echo "$1" | tr '[:lower:]' '[:upper:]')
        if [[ "$ARG_UPPER" == "LINE" ]]; then
            hrline
            exit 0
        fi
    fi
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help) show_help; exit 0 ;;
            -v|--version) echo "$PROGRAM_NAME v$VERSION"; exit 0 ;;
            -t|--timestamp) SHOW_TIMESTAMP=true; shift ;;
            -p|--pid) SHOW_PID=true; shift ;;
            -j|--json) OUTPUT_JSON=true; shift ;;
            -c|--no-color) DISABLE_COLOR=true; shift ;;
            --tag) LOG_TAG="$2"; shift 2 ;;
            --tag=*) LOG_TAG="${1#*=}"; shift ;;
            --path) LOG_PATH="$2"; shift 2 ;;
            --path=*) LOG_PATH="${1#*=}"; shift ;;
            --filename) LOG_FILENAME="$2"; shift 2 ;;
            --filename=*) LOG_FILENAME="${1#*=}"; shift ;;
            --max-size) MAX_SIZE="$2"; shift 2 ;;
            --max-size=*) MAX_SIZE="${1#*=}"; shift ;;
            --max-files) MAX_ROTATED_FILES="$2"; shift 2 ;;
            --max-files=*) MAX_ROTATED_FILES="${1#*=}"; shift ;;
            --display-tag) DISPLAY_TAG=true; shift ;;
            --no-display-tag) DISPLAY_TAG=false; shift ;;
            --display-tag=*) DISPLAY_TAG="${1#*=}"; shift ;;
            --no-display-tag=*) DISPLAY_TAG="${1#*=}"; shift ;;
            -*) echo "Error: Unknown option $1" >&2; show_help >&2; exit 1 ;;
            *) break ;;
        esac
    done
    
    if [[ $# -lt 2 ]]; then
        echo "Error: Missing required arguments" >&2
        echo "Usage: $PROGRAM_NAME LEVEL \"message\"" >&2
        exit 1
    fi
    
    LEVEL=$(echo "$1" | tr '[:lower:]' '[:upper:]')
    shift
    MESSAGE="$*"
    
    clog "$LEVEL" "$MESSAGE"
fi
